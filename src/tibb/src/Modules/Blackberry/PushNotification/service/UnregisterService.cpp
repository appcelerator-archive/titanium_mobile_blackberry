/*!
* Copyright (c) 2012, 2013  BlackBerry Limited.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

#include "UnregisterService.hpp"
#include <QDebug>

UnregisterService::UnregisterService(QObject *parent)
    : QObject(parent)
    , m_reply(0)
{
    // Connect to the sslErrors signal in order to see what errors we get when connecting to the push initiator
    connect(&m_accessManager,SIGNAL(sslErrors(QNetworkReply*, const QList<QSslError>&)),
            this, SLOT(onSslErrors(QNetworkReply*, const QList<QSslError>&)));
}

User UnregisterService::getCurrentlyRegisteredUser()
{
    return m_userDAO.user();
}

void UnregisterService::removeUser()
{
    m_userDAO.remove();
}

void UnregisterService::unsubscribeFromPushInitiator(const User& user)
{
    // Keep track of the current user's information
    // If it matches the one stored then it will be removed on success
    m_currentUser = user;

    const Configuration config = m_configurationService.configuration();

    QUrl url(config.pushInitiatorUrl() + "/unsubscribe");
    url.addQueryItem("appid",config.providerApplicationId());
    url.addQueryItem("username",user.userId());
    url.addQueryItem("password",user.password());

    m_reply = m_accessManager.get(QNetworkRequest(url));

    // Connect to the reply finished signal.
    connect(m_reply, SIGNAL(finished()), this, SLOT(httpFinished()));
}

void UnregisterService::httpFinished()
{

    int code = -1;
    QString description;

    if (m_reply->error() == QNetworkReply::NoError) {
        // Load the data using the reply QIODevice
        const QString returnCode = QString::fromUtf8(m_reply->readAll());

        if (returnCode == "rc=200"){
            const User storedUser = getCurrentlyRegisteredUser();

            if ((m_currentUser.userId() == storedUser.userId()) && (m_currentUser.password() == storedUser.password())){
                // Remove the stored user information since the unregister was successful
                m_userDAO.remove();
            }

            // Success!
            code = 200;
        } else if (returnCode == "rc=10002") {
            code = 10002;
            description = tr("Error: The application ID specified in the configuration settings could not be found, or it was found to be inactive or expired.");
        } else if (returnCode == "rc=10007") {
            code = 10007;
            description = tr("Error: The subscriber (matching the username and password specified) could not be found.");
        } else if (returnCode == "rc=10020") {
            code = 10020;
            description = tr("Error: The subscriber ID generated by the Push Initiator (based on the username and password specified) was null or empty, "
                             "longer than 42 characters in length, or matched the 'push_all' keyword.");
        } else if (returnCode == "rc=10025") {
            code = 10025;
            description = tr("Error: The Push Initiator application has the bypass subscription flag set to true (so no unsubscribe is allowed).");
        } else if (returnCode == "rc=10026") {
            code = 10026;
            description = tr("Error: The username or password specified was incorrect.");
        } else if (returnCode == "rc=10027") {
            code = 10027;

            // Note: You obviously would not want to put an error description like this, but we will to assist with
            // debugging
            description = tr("Error: A CPSubscriptionFailureException was thrown by the onUnsubscribeSuccess method of the implementation "
                             "being used of the ContentProviderSubscriptionService interface.");
        } else if (returnCode == "rc=-9999") {
            code = -9999;
            description = tr("Error: General error (i.e. rc=-9999).");
        } else {
            description = tr("Error: Unknown error code: %0.").arg(returnCode);
        }
    } else {
        code = m_reply->error();
        description = m_reply->errorString();
    }

    emit piDeregistrationCompleted(code, description);

    // The reply is not needed now we use deleteLater since we are in a slot.
    m_reply->deleteLater();
}

void UnregisterService::onSslErrors(QNetworkReply * reply, const QList<QSslError> & errors)
{
    // Ignore all SSL errors here to be able to load from a secure address.
    // It might be a good idea to display an error message indicating that security may be compromised.
    // The errors we get are:
    // "SSL error: The issuer certificate of a locally looked up certificate could not be found"
    // "SSL error: The root CA certificate is not trusted for this purpose"
    // Seems to be a problem with how the server is set up and a known QT issue QTBUG-23625

    reply->ignoreSslErrors(errors);
}
