/**
 * Appcelerator Titanium Mobile
 * Copyright (c) 2009-2012 by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */

#include "NativeProxyObject.h"

#include "NativeLoggerObject.h"
#include "NativeMessageStrings.h"
#include "TiEvent.h"
#include "TitaniumRuntime.h"

const char* NativeProxyObject::tetACCEPTED = "accepted";
const char* NativeProxyObject::tetCHANGE = "change";
const char* NativeProxyObject::tetBEFORELOAD = "beforeload";
const char* NativeProxyObject::tetCLICK = "click";
const char* NativeProxyObject::tetCONNECTED = "connected";
const char* NativeProxyObject::tetERROR = "error";
const char* NativeProxyObject::tetLOAD = "load";
const char* NativeProxyObject::tetREADYSTATECHANGE = "readystatechange";
const char* NativeProxyObject::tetSTARTED = "started";
const char* NativeProxyObject::tetDATA = "data";


NativeProxyObject::NativeProxyObject(TiObject* tiObject)
    : NativeObject(tiObject)
{
}

NativeProxyObject::~NativeProxyObject()
{
}

int NativeProxyObject::fireEvent(const char* name, const TiObject* event) const
{
    EventPairSmartPtr ep = events_.value(name);
    if (ep.get() != NULL && ep->container())
    {
        if (event != NULL)
        {
            ep->container()->fireEvent(event);
        }
        else
        {
            ep->container()->fireEvent();
        }
        return NATIVE_ERROR_OK;
    }
    N_WARNING(Native::Msg::Unsupported_event_name_ << name);
    return NATIVE_ERROR_NOTSUPPORTED;
}

int NativeProxyObject::setEventHandler(const char* eventName, TiEvent* event)
{
    TiEventContainer* container;
    if (events_.contains(eventName)) {
        container = events_[eventName]->container();
    } else {
        TiEventContainerFactory* factory = TitaniumRuntime::instance()->objectFactory()->getEventContainerFactory();
        container = factory->createEventContainer();
        events_.insert(eventName, EventPairSmartPtr(container, NULL));
    }

    event->setId(getNextEventId());
    container->addListener(event);
    return NATIVE_ERROR_OK;
}

int NativeProxyObject::removeEventHandler(const char* eventName, int eventId)
{
    if (events_.contains(eventName))
    {
        events_[eventName]->container()->removeListener(eventId);
        return NATIVE_ERROR_OK;
    }
    return NATIVE_ERROR_NOTSUPPORTED;
}

int NativeProxyObject::getNextEventId()
{
    static int s_nextEventId = 1;

    // Account for overflow.
    if (s_nextEventId < 1)
    {
        // This event id must start at 1 because 0 is reserved. Since
        // V8 will always cast a value of undefined to zero.
        s_nextEventId = 1;
    }
    return s_nextEventId++;
}


/* -- EventPairSmartPtr Implementation -- */
EventPairSmartPtr::EventPairSmartPtr():
    eventPtr_(NULL)
{
}

EventPairSmartPtr::EventPairSmartPtr(const EventPairSmartPtr& eventPtr)
{
    eventPtr_ = eventPtr.eventPtr_;
    if (eventPtr_ != NULL)
    {
        eventPtr_->addRef();
    }
}

EventPairSmartPtr::EventPairSmartPtr(EventPair* eventPtr)
{
    eventPtr_ = eventPtr;
    if (eventPtr_ != NULL)
    {
        eventPtr_->addRef();
    }
}

EventPairSmartPtr::EventPairSmartPtr(TiEventContainer* c, QObject* h)
{
    eventPtr_ = new EventPair(c, h);
}

EventPairSmartPtr::~EventPairSmartPtr()
{
    if (eventPtr_ != NULL)
    {
        eventPtr_->release();
        eventPtr_ = NULL;
    }
}

EventPairSmartPtr& EventPairSmartPtr::operator=(const EventPairSmartPtr& eventPtr)
{
    if (eventPtr.eventPtr_ != NULL)
    {
        eventPtr.eventPtr_->addRef();
    }
    if (eventPtr_ != NULL)
    {
        eventPtr_->release();
    }
    eventPtr_ = eventPtr.eventPtr_;
    return *this;
}

EventPair* EventPairSmartPtr::operator->() const
{
    return eventPtr_;
}

EventPair* EventPairSmartPtr::get() const
{
    return eventPtr_;
}
